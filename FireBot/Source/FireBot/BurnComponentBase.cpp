//=======================================================================================
// SkookumScript Plugin for Unreal Engine 4
// Copyright 1998-2020 Epic Games, Inc. All Rights Reserved.
//
// Behavior component C++ example 
//
// Author: Markus Breyer
//=======================================================================================

//=======================================================================================
// Includes
//=======================================================================================

#include "BurnComponentBase.h"
#include "Particles/ParticleSystem.h"
#include "Particles/ParticleSystemComponent.h"
#include "Components/MeshComponent.h"
#include "Kismet/GameplayStatics.h"

#include <SkookumScript/SkInstance.hpp>
#include <SkookumScript/SkInvokedMethod.hpp>
#include <SkookumScript/SkInvokedCoroutine.hpp>
#include <SkookumScript/SkInteger.hpp>
#include <SkookumScript/SkReal.hpp>


#include <SkUEBurnComponentBase.generated.hpp> 

//---------------------------------------------------------------------------------------

UBurnComponentBase::UBurnComponentBase(const FObjectInitializer & object_initializer)
  : Super(object_initializer)
	, mSocketName(TEXT("root"))
{
}

//---------------------------------------------------------------------------------------

void UBurnComponentBase::EnableBurn(bool enable)
	{
	if (mPSComponent)
		{
		if (enable)
			{
			mPSComponent->bSuppressSpawning = false; //Attempting to use activate/deactivate on ParticleSystems doesn't work because this is Unreal.
			IsBurning = true;
			}
		else
			{
			mPSComponent->bSuppressSpawning = true;
			IsBurning = false;
			}
		}
  }

//---------------------------------------------------------------------------------------

void UBurnComponentBase::mthd_do_stuff(SkInvokedMethod * scope_p, SkInstance ** result_pp)
  {
  if (result_pp) // Do nothing if result not desired
    {
    // Get this pointer if needed
    UBurnComponentBase * this_p = scope_p->this_as<SkUEBurnComponentBase>();

    // Get Sk argument 1 as Integer
    tSkInteger argument = scope_p->get_arg<SkInteger>(SkArg_1);

    // Add 42 and return result
    *result_pp = SkInteger::new_instance(argument + 42);
    }
  }

//---------------------------------------------------------------------------------------

bool UBurnComponentBase::coro_coro(SkInvokedCoroutine * scope_p)
  {
  UBurnComponentBase * this_p = scope_p->this_as<SkUEBurnComponentBase>();

  // Just started?
  if (scope_p->m_update_count == 0u)
    {
    // This code is run the first frame the coroutine runs

    // Get Sk argument 1 as Real (duration)
    tSkReal duration = scope_p->get_arg<SkReal>(SkArg_1);

    // If no duration, exit immediately
    if (duration <= 0.0f)
      {
      return true;
      }

    // Otherwise, set next update time (if not set will update next frame)
    scope_p->m_update_next = SkookumScript::get_sim_time() + f64(duration);

    // Coroutine not complete yet - call again when resumed
    return false;
    }

  // For a generic coroutine, might check here if we are really done and if not, return false to continue waiting

  // Ok done
  return true;
  }

//---------------------------------------------------------------------------------------

void UBurnComponentBase::register_bindings()
  {
  // Instance methods
  static const SkClass::MethodInitializerFunc methods_i[] =
    {
				{ "do_stuff",         mthd_do_stuff },
    };

  // Coroutines
  static const SkClass::CoroutineInitializerFunc coroutines_i[] =
    {
        { "_coro",            coro_coro },
    };

  // Register methods and coroutines with SkookumScript
  // Note: The SkUEBurnComponentBase class has been auto-generated by the SkookumScriptGenerator plugin for UnrealHeaderTool
  SkUEBurnComponentBase::get_class()->register_method_func_bulk(methods_i, A_COUNT_OF(methods_i), SkBindFlag_instance_no_rebind);
  SkUEBurnComponentBase::get_class()->register_coroutine_func_bulk(coroutines_i, A_COUNT_OF(coroutines_i), SkBindFlag_instance_no_rebind);

  }

//---------------------------------------------------------------------------------------

void UBurnComponentBase::OnRegister()
{
  Super::OnRegister();
}

//---------------------------------------------------------------------------------------

void UBurnComponentBase::InitializeComponent()
{
  Super::InitializeComponent();

	// Load fire fx, get the owner's mesh, and spawn the effect at startup
	UParticleSystem* PS = LoadObject<UParticleSystem>(NULL, TEXT("/Game/StarterContent/Particles/P_Fire.P_Fire"), NULL, LOAD_None, NULL);

	AActor* pOwner = GetOwner();
	UMeshComponent* mesh = Cast<UMeshComponent>(pOwner->GetComponentByClass(UMeshComponent::StaticClass()));

	mPSComponent = UGameplayStatics::SpawnEmitterAttached(PS, mesh, mSocketName, FVector(ForceInit), FRotator::ZeroRotator, EAttachLocation::SnapToTarget);
	EnableBurn(false);
}

//---------------------------------------------------------------------------------------

void UBurnComponentBase::BeginPlay()
{
  Super::BeginPlay();
}

//---------------------------------------------------------------------------------------

void UBurnComponentBase::EndPlay(const EEndPlayReason::Type end_play_reason)
{
  Super::EndPlay(end_play_reason);
}

//---------------------------------------------------------------------------------------

void UBurnComponentBase::UninitializeComponent()
{
  Super::UninitializeComponent();
}

//---------------------------------------------------------------------------------------

void UBurnComponentBase::OnUnregister()
{
  Super::OnUnregister();

// @TODO: causing a crash whenever editing a BP that holds this component for some reason
// 	if (mPSComponent)
// 		mPSComponent->DestroyComponent();
}
